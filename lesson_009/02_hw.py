# Теоретический комментарий:
# 1. Динамическое определение функций (def):
# В Python можно определять функции внутри других функций. Такие функции могут создаваться и возвращаться. Это основа для создания "фабрик функций" - функций, создающих функции.
#
# 2. Лямбда-функции:
# Лямбда-функции в Python — это анонимные функции, определённые одной строкой. Они удобны для создания простых функций на лету, особенно когда функция нужна временно или для одноразового использования.
#
# 3. Вызываемые объекты (__call__):
# В Python у класса может быть метод __call__, что позволяет его экземплярам вести себя как функции. Это дает возможность создавать объекты, которые могут быть вызваны как функции и хранить состояние между вызовами.
# Задание:
# Задача 1: Фабрика Функций
# Написать функцию, которая возвращает различные математические функции (например, деление, умножение) в зависимости от переданных аргументов.
#
# Задача 2: Лямбда-Функции
# Использовать лямбда-функцию для реализации простой операции и написать такую же функцию с использованием def. Например, возведение числа в квадрат
#
# Задача 3: Вызываемые Объекты
# Создать класс с Rect c полями a, b которые задаются в __init__ и методом __call__, который возвращает площадь прямоугольника, то есть a*b.
#
# Комментарии к заданию:
# Фабрика функций для сложения и вычитания:
# def create_operation(operation):
#     if operation == "add":
#         def add(x, y):
#             return x + y
#         return add # возвращаем функцию, как объект!! Тут скобки не нужны
#     elif operation == "subtract":
#         def subtract(x, y):
#             return x - y
#         return subtract
# my_func_add = create_operation("add")
# print(my_func_add(1,2))
#
# Пример лямбда функции с аналогом через def
# multiply = lambda x, y: x * y
# print(multiply(2, 3)) # Выводит 6
#
# def multiply_def(x, y):
#    return x * y
# print(multiply_def(2, 3)) # Выводит 6
#
# Пример создания вызываемого объекта
# class Repeater:
#    def __init__(self, value):
#        self.value = value
#    def __call__(self, n):
#        return [self.value] * n
#
# repeat_five = Repeater(5)
# print(repeat_five(3)) # Выводит [5, 5, 5]
#
# Пример вывода программы
# Задача 1: Фабрика функций
# 6
# 2.0
# Error: Division by zero
# Задача 2 лямбда
# 16
# 16
# Задача 3: Вызываемые oбъекты
# Стороны: 2, 4
# Площадь: 8

def create_operation(operation):
    if operation == "умножение":
        def add(x, y):
            return x * y

        return add  # возвращаем функцию, как объект!! Тут скобки не нужны
    elif operation == "деление":
        def subtract(x, y):
            return x / y

        return subtract


my_func_add = create_operation("деление")
print(my_func_add(1, 2))
